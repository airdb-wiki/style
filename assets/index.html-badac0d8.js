import{_ as a,M as t,p as l,q as s,R as e,t as n,N as o,a1 as i}from"./framework-5866ffd3.js";const c="/style/images/goroutine-scheduler-model.png",d={},h=e("h1",{id:"学习资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#学习资料","aria-hidden":"true"},"#"),n(" 学习资料")],-1),u={href:"https://www.jishuchi.com/read/gin-practice/3824",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.crblog.cc/golang/_book/gin/gin%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html",target:"_blank",rel:"noopener noreferrer"},g=e("h1",{id:"golang-常见问题收录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#golang-常见问题收录","aria-hidden":"true"},"#"),n(" Golang 常见问题收录")],-1),p=e("h2",{id:"golang-常见问题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#golang-常见问题","aria-hidden":"true"},"#"),n(" Golang 常见问题")],-1),m={href:"https://mp.weixin.qq.com/s/MTf_4WEvCnCMKeQC_Wm_xw",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zhuanlan.zhihu.com/p/323271088",target:"_blank",rel:"noopener noreferrer"},b=e("h2",{id:"开源项目",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#开源项目","aria-hidden":"true"},"#"),n(" 开源项目")],-1),v={href:"https://github.com/campoy/golang-plugins",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"解析范式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#解析范式","aria-hidden":"true"},"#"),n(" 解析范式")],-1),G={href:"https://studygolang.com/articles/12023",target:"_blank",rel:"noopener noreferrer"},k=i(`<p>G-P-M模型</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#D4D4D4;">G:
表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。
P:
表示逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数&gt;=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。
M:
M代表着真正的执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。
</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+c+'" alt="" title="goroutine"></p>',3);function E(M,w){const r=t("ExternalLinkIcon");return l(),s("div",null,[h,e("ul",null,[e("li",null,[e("a",u,[n("Golang Gin 实践"),o(r)])]),e("li",null,[e("a",_,[n("gin源码分析"),o(r)])])]),g,p,e("ul",null,[e("li",null,[e("a",m,[n("Go sync.Pool 浅析"),o(r)])]),e("li",null,[e("a",f,[n("[典藏版]Golang调度器GPM原理与调度全分析"),o(r)])])]),b,e("ul",null,[e("li",null,[e("a",v,[n("Plugin 热更新问题"),o(r)])])]),x,e("p",null,[e("a",G,[n("Go Channel的实现"),o(r)])]),k])}const y=a(d,[["render",E],["__file","index.html.vue"]]);export{y as default};
